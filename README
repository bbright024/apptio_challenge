########
PROLOGUE
########

I had a lot of fun brainstorming solutions to problem A.  Part of me wonders
if I did too much planning, but I'm not a fan of tech debt I guess.

Problem B wasn't much of an option - it's an extended version of the last few
exercises in chapter 4 of "The Go Programming Language".  I spent a lot of time
learning how web-based API's
that respond 



#########
PROBLEM A
#########

The app devs have created a web app that generates a log file of the format:

<datetime logtime, string "message">

Your team has deployed the app in production, where the devs don't have access
to the log file on the servers local file system due to a security boundary.

The app devs want access to the contents of the log.

Write automation/program that will allow the devs to view the logs
without manual intervention.

#####
NOTES
#####

Initial thoughts:

I can think of a bunch of ways to tackle this issue.  A few are ruled out
due to the need for automation, and a few others are ruled out due to no
manual intervention.

The problem as stated isn't very clear, so I'm operating on a
couple of assumptions:
a) that a server admin can access the log file via ssh
b) 'manual intervention' means the devs don't talk to the admin
whenever they want to access the file

Ok, lightbulb clicked - the problem is similar to my proxy server.

#########
RESOURCES
#########

My HTTP proxy server solves a similar problem.
   a) take requests from clients over a socket
   b) read in and parse the requests
   c) access the requested resources
   d) write the results back to the client socket
   e) cache results for quicker access next time

"The Go Programming Language"
MIT 6.824 Lecture 7 - Guest lecture on Go by Russ Cox of Google/Go
Countless man pages
golang.org/pkg

#######################
DESIGN & IMPLEMENTATION
#######################
Solution:
Write a server program & deploy it on the main app host, and a
   client side program for devs to run on their own machines for easy access.

Issues:
     - Both server & client will be written in Go, for 3 reasons.
        1. Since Go compiles statically linked binaries, library dependencies
         	will not be an issue, making both programs easier to install.
	 	- could compile the client side program into many different
	  	    architectures and have them available for devs on an internal
		    website
	2. Go has really nice built-in concurrency that the server side program
	   can take advantage of when multiple requests come in simultaneously
	3. The proxy I wrote in C is very similar - copy/pasting would be no fun.
	
     - the server side app will need read access on the log file, and any
        archived log files.
     - server side installation and activation should be as simple as possible.
     - testing is tricky for client/server program combos
     - upgrades to the server side program API shouldn't break clients that assume
         an older API
     - if implementing RPC functions that only admins can run, authentication &
       accessibility should be split (kerberos would be nice to have)
     - caching results might be a security issue
     - big read requests of the log file could slow down the main app
     
   Ideally the server side program  would only be available to clients from
   the internal network. The server is live - we don't want customers
   nor blackhats to have access to the port the logging access program
   listens on.  

   Caching the log entries is definitely a goal - log entries will never
   be changed.  In the client-side program, caching would reduce network load.
   In the server side program, caching would reduce system calls & disk I/O requests,
   leaving more resources available for the main app. 

   Obviously, there are tons of issues I could work on.  However, the assignment is
   not supposed to be a month long affair, so my solution will progress in a few stages.

      a. bare-bones client & server programs that communicate over a network socket
      b. testing - write bash scripts with curl/wget/netcat
      c. prevent access from outside the internal network
      d. testing - try to access the server side program with netcat
      e. add logging & RPC functions 
      f. testing
      g. write a deployment script that takes 1 or more ip addresses & log location
      h. testing - make sure server side program can read log file
      i. add caching
      j. testing
      k. add RPC for admins
      l. testing

   To complete the assignment, at the very least I need to get to step h.  One could argue
   that the security aspect isn't necessary, as it wasn't specified as a goal in the assignment.
   However, I feel like it would be frowned upon if I ignored a huge vulnerability. Letting
   outside users have access to the application log files seems like a design flaw. 

   
############
ALTERNATIVES
############

I've included solutions that don't satisfy all requirements,
solutions that might satisfy all requirements (depending on interpretation)
and extra features that could be added to my solution.

- Give every dev root access on the app server (kidding)

- Write a caching client proxy server that forwards client requests.  If all clients go through
   the proxy, that cache is gonna be magnificent - it will reduce the strain on the
   main app server & speed up the main app in two ways:
   	1. amount of data sent to main app server is decreased
	    - more bandwidth for main app clients
   	2. amount of disk I/O requests & syscalls from server side is decreased
	    - more CPU time for main app clients
   
- Write a script that will copy the file via ssh
     -problem: requires manual intervention; admin needs to input
         password every time a dev needs access to the log

- In addition to my solution, add Kerberos to the network.  This
   would create a more secure environment for the API, since
   the authentication & authorization for RPC functions is seperated. 
     -problem: increases complexity of the system as a whole,
        could add latency to clients of the main app (minor issue -
	kerb would only be used for internal access)

- Add the log file to a group on the host OS, give that group read privileges,
   and add devs to the group. a cron job could be added to the
   host to add log archive files to that group with read privileges.
     -problem: assumes the original problem's 'security boundary'
         was only unix permission levels of the devs.  chown, chmod,
         and cron seem a little too easy.

- Add a rule to the ACL denying access to my solution program if the original
  IP address is outside the range that the company uses for internal addressing
     -problem: not really scaleable, and also requires the admin to update the rule
         on each server whenever the company changes or adds subnets in a new range.
	 
      

###############
DEPLOYMENT PLAN
###############
The program has to be deployed without taking the main app offline.
To read the file, the program has to be in the same namespace as the
main app.  The server admin should scp the binary into the proper
location on the server and execute the program.
Obviously, there is a problem with scale in this scenario - what if
the main app is on 500 servers?  Depending on the server environment,
the most basic solution is to write an install script that takes
the ip addresses of the machines hosting the main app.

###########################
MONITORING/REPORTING/ALERTS
###########################

Need to log every client IP.  


#############
CONFIGURATION
#############

Parameters set - allowed IP range, maximum cache size, maximum concurrent requests


#######
TESTING
#######
