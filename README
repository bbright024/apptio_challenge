########
PROLOGUE
########

Ahhh this is so exciting!  And nerve-wracking at the same time.  I can be a bit
verbose when I'm writing about something fun, so hopefully this isn't too long
for you guys at Apptio.

Presently, I'm typing this up at an equestrian eventing farm out in Kennewick, WA.
My girlfriend is a horse trainer, and when I can, I like to tag along and spectate.
Unfortunately, (or maybe fortunately in this case) that entails hours and hours of
driving, and possibly days without internet access.  I received this assignment right
before leaving on a 3 hour drive, so I had a lot of time to plan a course of action.  

I decided to do problem A, for a few reasons.  Problem B is pretty similar to
exercise 4.13 in "The Go Programming Language" - I spent a few days a week ago
working on 4.10 and 4.11, so writing more JSON fetching code in Go wouldn't be very
challenging.  Of course, I could turn it into a client/server setup and add a cache
and concurrency, but overall (B) is not nearly as interesting as (A).

(A) has a *ton* of solutions - partly because the question is so vague on the production
environment.  I'm guessing that was intentional!  Journey on, dear reader, and I'll
explain some solutions and some pros and cons of each.  If you just want to see the code,
well, that's fine, I'll probably talk your ears off about this stuff anyway whenever I
come in to meet you guys.  I've got way more questions about (A) than solutions.

#########
PROBLEM A
#########

The app devs have created a web app that generates a log file of the format:

<datetime logtime, string "message">

Your team has deployed the app in production, where the devs don't have access
to the log file on the servers local file system due to a security boundary.

The app devs want access to the contents of the log.

Write automation/program that will allow the devs to view the logs
without manual intervention.

#####
NOTES
#####

Initial thoughts:

I can think of a bunch of ways to tackle this issue.  A few are ruled out
due to the need for automation, and a few others are ruled out due to no
manual intervention.

Like I've said, the problem is vague.  Thus, my favorite solution
operates on a couple assumptions:
a) a server admin can gain root access via ssh
b) external access to the main app host machine is routed through a
   router or proxy under our control, allowing for easy port forwarding.
   Reasonable, I think, since one can easily do this in a home environment.
c) giving all the devs root access to the server isn't a viable solution

Whether or not the main app is chrooted/containerized away from the log file,
I don't think my solution would change.  
But you know what they say about 'assume' - they make an 'ass' of 'u' and 'me'.
Please let me know if I overstepped any bounds here!

#######################
DESIGN & IMPLEMENTATION
#######################
So if this were real life, and I got this request from the devs, I'd probably
put my head in my hands and groan.  The app is deployed and in production, which
means anyone on the web can access it, right?  And the log file is being stored
on the SAME MACHINE as the app, right?  Meaning if an attacker were able to grab
root on the machine, the log file is completely untrustworthy.  The situation
is kinda analagous to a race condition.

Thus my first step would be to cross my fingers & pray that the app hasn't been
compromised yet.  Next, if I could, I'd install rsyslog to get those log files
off the main host ASAP.  If rsyslog wasn't an option for whatever reason, I'd
write a small app that would monitor the log file for changes and write those
changes to a remote destination, making sure that the receiving app at the 
destination could only append local log files.  That way, you could be sure that
an attacker wouldn't be able to modify the files... but like I said, it's possible
an attacker already has root and you

HOWEVER, this is not real life.  


Solution:
Write a server program & deploy it on the main app host, and a
   client side program for devs to run on their own machines for easy access.

Issues:
     - Both server & client will be written in Go, for 3 reasons.
        1. Since Go compiles statically linked binaries, library dependencies
         	will not be an issue, making both programs easier to install.
	 	- could compile the client side program into many different
	  	    architectures and have them available for devs on an internal
		    website
	2. Go has really nice built-in concurrency that the server side program
	   can take advantage of when multiple requests come in simultaneously
	3. The proxy I wrote in C is very similar - copy/pasting would be no fun.
	
     - the server side app will need read access on the log file, and any
        archived log files.
     - server side installation and activation should be as simple as possible.
     - testing is tricky for client/server program combos
     - upgrades to the server side program API shouldn't break clients that assume
         an older API
     - if implementing RPC functions that only admins can run, authentication &
       accessibility should be split (kerberos would be nice to have)
     - caching results might be a security issue
     - big read requests of the log file could slow down the main app
     
   Ideally the server side program  would only be available to clients from
   the internal network. The server is live - we don't want customers
   nor blackhats to have access to the port the logging access program
   listens on.  

   Caching the log entries is definitely a goal - log entries will never
   be changed.  In the client-side program, caching would reduce network load.
   In the server side program, caching would reduce system calls & disk I/O requests,
   leaving more resources available for the main app. 

   Obviously, there are tons of issues I could work on.  However, the assignment is
   not supposed to be a month long affair, so my solution will progress in a few stages.

      a. bare-bones client & server programs that communicate over a network socket
      b. testing - write bash scripts with curl/wget/netcat
      c. prevent access from outside the internal network
      d. testing - try to access the server side program with netcat
      e. add logging & RPC functions 
      f. testing
      g. write a deployment script that takes 1 or more ip addresses & log location
      h. testing - make sure server side program can read log file
      i. add caching
      j. testing
      k. add RPC for admins
      l. testing

   To complete the assignment, at the very least I need to get to step h.  One could argue
   that the security aspect isn't necessary, as it wasn't specified as a goal in the assignment.
   However, I feel like it would be frowned upon if I ignored a huge vulnerability. Letting
   outside users have access to the application log files seems like a design flaw. 

   
############
ALTERNATIVES
############

I've included solutions that don't satisfy all requirements,
solutions that might satisfy all requirements (depending on interpretation)
and extra features that could be added to my solution.

- Give every dev root access on the app server (kidding)

- Write a caching client proxy server that forwards client requests.  If all clients go through
   the proxy, that cache is gonna be magnificent - it will reduce the strain on the
   main app server & speed up the main app in two ways:
   	1. amount of data sent to main app server is decreased
	    - more bandwidth for main app clients
   	2. amount of disk I/O requests & syscalls from server side is decreased
	    - more CPU time for main app clients
   
- Write a script that will copy the file via ssh
     -problem: requires manual intervention; admin needs to input
         password every time a dev needs access to the log

- In addition to my solution, add Kerberos to the network.  This
   would create a more secure environment for the API, since
   the authentication & authorization for RPC functions is seperated. 
     -problem: increases complexity of the system as a whole,
        could add latency to clients of the main app (minor issue -
	kerb would only be used for internal access)

- Add the log file to a group on the host OS, give that group read privileges,
   and add devs to the group. a cron job could be added to the
   host to add log archive files to that group with read privileges.
     -problem: assumes the original problem's 'security boundary'
         was only unix permission levels of the devs.  chown, chmod,
         and cron seem a little too easy.

- Add a rule to the ACL denying access to my solution program if the original
  IP address is outside the range that the company uses for internal addressing
     -problem: not really scaleable, and also requires the admin to update the rule
         on each server whenever the company changes or adds subnets in a new range.
	 
      

###############
DEPLOYMENT PLAN
###############
The program has to be deployed without taking the main app offline.
To read the file, the program has to be in the same namespace as the
main app.  The server admin should scp the binary into the proper
location on the server and execute the program.
Obviously, there is a problem with scale in this scenario - what if
the main app is on 500 servers?  Depending on the server environment,
the most basic solution is to write an install script that takes
the ip addresses of the machines hosting the main app.

###########################
MONITORING/REPORTING/ALERTS
###########################

Need to log every client IP.  


#############
CONFIGURATION
#############

Parameters set - allowed IP range, maximum cache size, maximum concurrent requests


#######
TESTING
#######


#########
RESOURCES
#########

My HTTP proxy server solves a similar problem.
   a) take requests from clients over a socket
   b) read in and parse the requests
   c) access the requested resources
   d) write the results back to the client socket
   e) cache results for quicker access next time

"The Go Programming Language"
MIT 6.824 Lecture 7 - Guest lecture on Go by Russ Cox of Google/Go
Countless man pages
golang.org/pkg

Timestamp 1:00:00 to end of 6.858 Lecture 4 Privelege Seperation - https://www.youtube.com/watch?v=XnBJc3-N2BU
    "What happens if the log daemon of a web app is compromised"